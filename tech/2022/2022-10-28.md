# SPDX Tech Team Meeting - 28 October, 2022

## Attendees
* Alexios Zavras
* Bob Martin
* David Kemp
* Gary O'Neall
* Jeff Schutt
* Kate Stewart
* Maximilian Huber
* Sean Barnum
* Sebastian Crane
* Thomas Steenbergen
* William Bartholomew

##Agenda
* Reduce down the punch list for 3.0 Model - what is criteria for "release candidate"?
* Mechanical topics on how to document, and move content into 3.0

## Notes
### Mechanical Concerns
* How start to write documentation?
* Work off of actual examples of serialized format.

Summary from Alexios: Intent is to create a new specification, along with examples. Big reason for examples is to demonstrate SPDX to other parties (e.g. tooling developers), however examples are time-consuming to create if done before the specification is defined. Would have specification documents automatically generated from definitions of properties and types.

Sean: Would recommend doing
        • Formal ontology (RDF/OWL/SHACL)
           • Autogenerated text documentation from formal ontology
           • Serialization specs (binding rules for creating serialized content from model)
       • Examples
                ○ Important to ensure they are valid using formal ontology and SHACL validation
       • Textual specs for profiles

Quote Bob: "Use examples to explore what we're documenting"

Sean: Examples are great, but easy to overlook small details, and UCO[expand acronym] & Case work illustrated this.   Show

It is noted that examples are most likely to be snippets of complete SPDX files, intended to demonstrate a single concept. This is a consideration for automatic validation of examples during publication. However, making sure that examples showing subparts aren't likely to be taken out of context by readers is important.

It is noted that, for ISO submission, explantion of the migration path from prior versions must be a critical part of the SPDX 3.0 specification. Consider the difference between auto-generated and hand-written SPDX documents, and how SPDX 3.0 is likely to be more automation-focused than previous versions.

Discussion of whether the current lack of structure for writing specification chapters is impeding progress with subcommittees and profile development.

Alexios to get together with Steve Winslow, to see if we can work through licensing profile with own classes and definition. It is concluded with agreement of those present that once the legal team is "unblocked", then will work through with other teams (possibly in main Tech Team call).

### SPDX 3.0 Model discussion
Working from top to bottom through https://github.com/spdx/spdx-3-model/issues/29 - plan is to create an agenda for a Tech Team meeting which will be circulated on the Tech Team mailing list.

#### Snippet

Context is agreement in previous Tech Team call is to deprecate or remove the RDF 'line and byte pointers' method of locating snippets within files and replace with more straightforward.

#### Proposed 'Data' Element type to describe content of snippet/file

Context is the idea of Alexios and subsequent proposal by Sebastian to add a 'Data' Element type to describe the content of a snippet of file, allowing for reuse of elements when the names or locations of files/snippets differ but their content does not.

Jeff suggests the use of the gitoid format (derived from a hash on range of bytes) as an optional (or potentially mandatory) identifier on 'Data' Element. Could be dependent on the existence of said 'Data' Element.

Alexios considers the separatation of the content of snippet/files from those snippet/files to be too large a change for 3.0.

Max comments this change would not work for tools. Quote Max: "In tools I do not always have the file and know its content. I can not always compute the identifier in that case".

Jeff is willing to support a change proposal, but is not sure that it should be more than an identifier for range of bytes. Willilam noted that it is important to understand the location of a snippet in some cases.

Sean asserted that identifier only applies to content.

Gary proposes property on artifact - "content" - which is identified by a gitoid, which differs from the initial suggestion.

David queries whether gitoid (a hash of a byte sequence) is not a "verified_by" value, rather than an "identifier". There is some positive reception in the meeting chat.

Action point: Sebastian will writing a change proposal baesd on Alexios's original idea.

Jeff agree with Gary's (oral) proposal, as you are tracking the metadata, location and identifier of software are useful.   Had a property on artifact in previous draft diagrams for SPDX 3.0. Could add a content property on file, snippet, package.   More complexity with relationships can be discussed later.   Misunderstanding on what to put into hash - needs to be clarified in 2.0 documentation.

Summary:
    1) Capture gitoid information for identity on file, package, snippet.
    2) Summarize a change proposal on how snippet, file and content could relate.   Thinking that it is an additive change, so likely target for 3.1   Need to reconcile Sebastian, Jeff and Gary's viewpoints.
    3) Sebastian to write proposal for 3.1;  will share with Jeff for review before to align, and move forward.

#### File Download Location

Context is that we used to have a Download Location property on Package. Question is whether or not to have an analogous field on File or Artefact.
Intent of File is that it isn't individually distributable.    It is unclear whether or not it makes sense as a property on File.

Gary feels that it should only be at the package level for download location.   File could be distributed, but at that point is described by an SPDX Package.  If 'Data' (see ealier section) is intended to be distributed, it should also put in a package.

Jeff discussed use cases and consider a snippet, associated with a download location, where it came from.
Sebastian expresses scenario of downloading file by file from http server, and in this case the SPDX document would reflect one package for each file that downloaded. Sebastian's suggestion is therefore to review documentation to make it clearer that SPDX is from the perspective of the document's  creator.

William notes that the External Download Location (suggested in a previous Tech Team meeting) can be used with any Element, so that is a way to make it happen.

** Decision **  Rough consensus is that this will not be added in 3.0, but can be revisited for 3.1

#### Cardinality on homepage

Sean queries whether is it intended to be singular as its chief reason, ie. the authorative webpage among many.
Gary responds that one site was supposed to be authorative.
Suggest adding another External Reference type for homepage, rather than changing the cardinality.
Sean suggested it as "authorative" - analogous to download location and home page as property on package.  Others go into external download location.
Jeff has seen useful to have homepage, but term may be too vague.   Related URLs aggregated in same place might be appropriate?
William - property on package for homepage,  external reference use to list any additional references to provide information to consumers.
Jeff wants to make it easy for people to use a spec.

William want to see following the property being authorative, external references allow for alternates.

Jeff thinking about security profile, how handle advisories?   Does it make sense to elevate to level of property?  Based on use cases.

David identity resolution, indicates more information gives confidence same thing.

** Decision ** Homepage is left as a property in 3.0 and added as external alt-webpage reference.


#### Package field coverage review

Kate to review 2.3 spec properties, compared to model, and make sure we have mapping.   Send mail to list.

####  Artifact URI

Elevating a property to level of package makes sense.

Jeff looking for two identifier - actual software artifact, as well as document that describes all the dependencies.
William - reference via external reference (so know what you're looking at) and then gitoid, would be an external identifier on the package.

Some confusion - external references vs. external identifiers.

Should Artifact URI remain, or should it be on specific sub components.    For the source case, why wouldn't you want to have that identifier for the file.

External identifier - maintained by a system external to SPDX.  Maintained by someone other that SPDX.
URI on artifact lets folks use it when they want.   May not be natural URI for snippet and files.    At individual class level where it's defined.

Downstream wants to see that content is in multiple locations.

1) Identity of Element - SPDXID  - would identify byte range.
2) Identity of Content. - ContentID or VerifiedUsing - so can match other places where it exists.

PURL is a package as a property  (some use as identity, some use as a locator).
ContentID:  File - Gitoid
ContentID:  Snippet - Gitoid

Does it make sense for artifact?  No, as artifact could be hardware.
Verified using is on element (which is artifact).   As it refers to conent.

Is the content unique id, same as verified using?   Not necessarily, as there may be other content schemes you can't use as an identifier.

Verified using - ways to do it today.   Continues to support this use case.   Extension of content hashes in 2.X.   Example signatures could be used as verified using.   Integrity matchs what meta data describes.

** Decision ** Content identifier should be applied as a property in snippet, file, package.   Not using external identifier.
** Decision ** Consensus that Gitoid is the way to provide content identifier.  Cardinality and use?   Optional field  (0..1)


#### Discussion on Extension Points

Next steps:  Canonicalization to present to whole tech group how canonicalization works.

One of canonicalization rules be "ignore extensions"
We should not be trying to canonicalize PURLs.  - canoncialize are URI.
We need to see a full list of what is canonicalized, and what is not.

Next steps:
    * Model repo has 1 PR by Sebastian and 1 by Max, for drawio
    * William to upload the latest diagram
    * Kate to review fields in Package level
